/**
 * 큰 수의 법칙
 * '큰 수의 법칙'은 일반적으로 통계 분야에서 다루어지는 내용이지만 동빈이는 본인만의 방식으로 다르게 사용하고 있다.
 * 동빈이의 큰 수의 법칙은 다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙이다.
 * 단, 배열의 특정한 인덱스(번호)에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것이 이 법칙의 특징이다.
 *
 * 예를 들어 순서대로 2, 4, 5, 4, 6 으로 이루어진 배열이 있을 때, M이 8이고, K가 3이라고 가정하자.
 * 이 경우 특정한 인덱스의 수가 연속해서 세 번까지만 더해질 수 있으므로 큰 수의 법칙에 따른 결과는 6 + 6 + 6 + 5 + 6 + 6 + 6 + 5인 46이 된다.
 *
 * 단, 서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로 다른 것으로 간주한다.
 * 예를 들어 순서대로 3, 4, 3, 4, 3으로 이루어진 배열이 있을 때 M이 7이고, K가 2라고 가정하자.
 * 이 경우 두 번째 원소에 해당하는 4와 네 번째 원소에 해당하는 4를 번갈아 두 번씩 더하는 것이 가능하다.
 * 결과적으로 4 + 4 + 4 + 4 + 4 + 4 + 4 인 28이 도출된다.
 * 배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때 동빈이의 큰 수의 법 칙에 따른 결과를 출력하시오.
 *
 * 입력 예시 : N = 5, M = 8, K = 3, arr = [2, 4, 5, 4, 6]
 * 출력 예시 : 46
 */

/**
 * 문제 해결 방법
 * 1. 가장 큰 수부터 더해야한다.
 */

function solution(m, k, arr) {
  let result = 0;
  arr.sort((a, b) => b - a); // [6, 5, 4, 4, 2]

  while (true) {
    for (let i = 0; i < k; i++) {
      if (m === 0) {
        break;
      }
      result += arr[0];
      m--;
    }

    if (m === 0) {
      break;
    }

    result += arr[1];
    m--;
  }

  console.log(result);
}

solution(8, 3, [2, 4, 5, 4, 6]);
solution(7, 2, [3, 4, 3, 4, 3]);

/**
 * 내가 푼 방식은 단순하게 푼 방식으로 M의 크기가 커지면 시간 초과 판정을 받을 것이다.
 * 간단한 수학적 아이디어를 이용해 더 효율적으로 문제를 해결할 수 있다. 🌟반복되는 수열🌟
 *
 * "6 + 6 + 6 + 5", "6 + 6 + 6 + 5" 반복된다.
 * 이때 반복되는 수열의 길이는 바로 K + 1 이 된다. (K만큼 큰수를 최대한 더하고 그 다음 큰수를 한번 더하기때문)
 * 따라서 M을 (K + 1)로 나눈 몫이 수열이 반복되는 횟수가 된다.
 * 그리고 다시 여기에 K를 곱해주면 가장 큰 수가 등장하는 횟수가 된다.
 *
 * 즉 가장 큰 수가 더해지는 횟수는 아래와 간다.
 * (M / (K + 1)) * K + M % (K + 1)
 */

function solution2(m, k, arr) {
  arr.sort((a, b) => b - a);
  let result = 0;
  const count = parseInt(m / (k + 1)) * k + (m % (k + 1));

  result += arr[0] * count;
  result += (m - count) * arr[1];

  console.log(result);
}
solution2(8, 3, [2, 4, 5, 4, 6]);
solution2(7, 2, [3, 4, 3, 4, 3]);
